<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Category Mapping with Embedding | Lei Huang</title>
<meta name="keywords" content="">
<meta name="description" content="A deep dive into how I used embeddings and LLMs to automate a complex product categorization migration, cleaning up messy data along the way.">
<meta name="author" content="Lei Huang">
<link rel="canonical" href="https://leihuang.me/posts/category-mapping-with-embedding/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://leihuang.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://leihuang.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://leihuang.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://leihuang.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://leihuang.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://leihuang.me/posts/category-mapping-with-embedding/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://leihuang.me/posts/category-mapping-with-embedding/">
  <meta property="og:site_name" content="Lei Huang">
  <meta property="og:title" content="Category Mapping with Embedding">
  <meta property="og:description" content="A deep dive into how I used embeddings and LLMs to automate a complex product categorization migration, cleaning up messy data along the way.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-07-01T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Category Mapping with Embedding">
<meta name="twitter:description" content="A deep dive into how I used embeddings and LLMs to automate a complex product categorization migration, cleaning up messy data along the way.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://leihuang.me/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Category Mapping with Embedding",
      "item": "https://leihuang.me/posts/category-mapping-with-embedding/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Category Mapping with Embedding",
  "name": "Category Mapping with Embedding",
  "description": "A deep dive into how I used embeddings and LLMs to automate a complex product categorization migration, cleaning up messy data along the way.",
  "keywords": [
    
  ],
  "articleBody": "Recently, I faced a daunting task: migrating all of our existing product deals to a brand new, more comprehensive, and standardized set of canonical product categories. This was critical for improving product discoverability, ensuring consistent marketing, and enabling better reporting. Think of it as moving from a somewhat disorganized, ad-hoc filing system to a meticulously organized, hierarchical library catalog.\nThe problem? Our system had tens of thousands of deals, each with existing category assignments that were often inconsistent, incomplete, or simply didn’t map cleanly to the new structure. Manually re-categorizing everything was out of the question. It would have taken an absurd amount of time and been incredibly prone to errors. I needed an automated solution, but a simple keyword-based approach wouldn’t work. The nuances of product descriptions and the potential mismatches between the old and new categories demanded something far more intelligent.\nThe Challenge: Bridging the Old and New The core challenge was bridging the semantic gap between the existing (often messy) category assignments and the new canonical categories. Here are a few examples to illustrate the problem:\nOld: “mens-clothing.shirts-t-shirts” New: “Apparel.Men’s.Tops.T-Shirts” Old: “health-beauty.fragrance-cologne” New: “Beauty \u0026 Personal Care.Fragrances.Men’s Fragrances” Old: “home-decor” New: “Home \u0026 Garden.Home Decor.Candles \u0026 Home Fragrances” (for a scented candle deal) The old categories could be incomplete, use different wording, or have a different level of granularity. I couldn’t just create a simple lookup table. I needed a system that could:\nUnderstand the meaning of the product description, going beyond simple keyword matching. Leverage the existing category information, even if imperfect, as a valuable hint. Intelligently select the best match within the new canonical category hierarchy. My AI-Powered Solution: A Two-Stage Migration I developed a two-stage AI-powered system that combines the strengths of embedding-based similarity matching and the contextual reasoning of large language models (LLMs).\nStage 1: Embedding-Based Similarity – Finding the Right Neighborhood The first stage leverages pre-computed embeddings of the new canonical categories. Embeddings are numerical representations that capture the semantic meaning of text. Similar concepts have similar embeddings. I calculated the embedding of each product deal’s description (including the title and any existing category information, after some complex preprocessing). Then, I compared this “deal embedding” to the embeddings of all the top-level categories in the new taxonomy.\n// (Simplified representation) import { calculateCosineSimilarity } from './similarity'; import canonicalCategoryData from './canonical_categories.json'; // My NEW category embeddings import { getAIClient } from './ai_client'; // Interface to AI models async function migrateCategory(dealDetails) { const { title, description, existingCategories } = dealDetails; const { createTextEmbedding } = getAIClient(); // 1. Create an embedding for the deal, including (preprocessed) existing categories. const dealEmbedding = await createTextEmbedding( `${title} ${description} ${existingCategories ? prepareCategories(existingCategories) : ''}` ); // 2. Compare against top-level canonical category embeddings. const topLevelCategories = Object.entries(canonicalCategoryData) .map(([key, data]) =\u003e [key, data.embedding]); let bestMatch = null; let highestScore = -Infinity; for (const [categoryName, categoryEmbedding] of topLevelCategories) { const similarity = calculateCosineSimilarity(dealEmbedding, categoryEmbedding); if (similarity \u003e highestScore) { highestScore = similarity; bestMatch = categoryName; } } // ... (continued below) } I used cosine similarity to measure how “close” the embeddings are. A score of 1 is a perfect match; -1 is completely opposite. This quickly and efficiently identifies the general area within the new category structure where the deal likely belongs. If the similarity score exceeds a threshold (I used 0.8), I’m confident enough to assign the deal to that top-level category. Then, I repeat the process with the sub-categories of that top-level to get a more precise placement (e.g., “Apparel” -\u003e “Men’s” -\u003e “Tops” -\u003e “T-Shirts”).\nStage 2: LLM Reasoning – Refining the Choice What if the embedding similarity is below my threshold? This is where the LLM comes in, handling cases where:\nThe deal description is brief or uses unusual language. The existing categories are particularly unhelpful or misleading. The best fit in the new taxonomy isn’t immediately obvious. I construct a prompt for the LLM that includes:\nThe deal’s title and description. The (potentially cleaned-up) existing categories. A list of the new canonical categories to choose from. // (Continuing from the previous code snippet) const SIMILARITY_THRESHOLD = 0.8; async function migrateCategory(dealDetails) { // ... (previous code) // If similarity is high enough, we're done! if (highestScore \u003e= SIMILARITY_THRESHOLD) { const subCategories = canonicalCategoryData[bestMatch].children; // Get sub-categories const subCategoryMatch = await findBestSubCategory(dealEmbedding, subCategories); // Find the best sub-category return [bestMatch, subCategoryMatch].filter(Boolean).join('.'); // Return \"TopLevel.SubLevel\" } // If similarity is low, bring in the LLM. const availableCategories = topLevelCategories.map(([categoryName]) =\u003e categoryName); const suggestedCategory = await getCategorySuggestion(dealDetails, availableCategories); return suggestedCategory; } The getCategorySuggestion function (shown later) interacts with the LLM, providing the prompt and receiving the suggested category. The LLM acts like a “smart categorizer,” using its contextual understanding to make the best decision.\nThe Key: Cleaning Up the Existing Categories The most crucial and, I think, trickiest part of my solution is how I handle the existing category information. I can’t just ignore it; it often contains valuable clues. But I can’t trust it blindly, either. The refineExistingCategories function is the key to this delicate balance.\nexport function refineExistingCategories(categories: string, similarityScores: number[]): string { const keywords = categories .split(',') .map((cat) =\u003e cat.split('.').map((subCat) =\u003e subCat.split('-'))) let i = 0; function filterKeywords(arr: any[]): any[] { return arr .map((item) =\u003e { if (Array.isArray(item)) { return filterKeywords(item) } // THIS IS THE CORE LOGIC: Remove keywords with low similarity. return similarityScores[i++] \u003e KEYWORD_SIMILARITY_THRESHOLD ? item : null }) .filter((item) =\u003e item !== null) } return (filterKeywords(keywords) as string[][][]) .map((category) =\u003e category .map((subCategory) =\u003e { return subCategory.join('-') }) .join('.') ) .join(',') } Here’s a breakdown:\nDeconstruct: I break down the existing categories into a hierarchical structure of individual keywords. For example, “health-beauty.fragrance-cologne,mens-clothing” becomes [[[\"health\", \"beauty\"], [\"fragrance\", \"cologne\"]], [[\"mens\", \"clothing\"]]].\nIndividual Keyword Embeddings: I create an embedding for each individual keyword from the old categories.\nSimilarity Check: I compare each keyword embedding to the embedding of the deal description ( without the old categories). This measures how relevant each individual keyword is to the core product information.\nStrategic Removal: If a keyword’s similarity is below a threshold (KEYWORD_SIMILARITY_THRESHOLD, which I set to 0.75), I remove it. This eliminates noise and prevents misleading information from influencing the LLM.\nReconstruct: I rebuild the “cleaned” existing categories string using only the remaining keywords.\nExample:\nLet’s say a deal for a men’s cologne has the old category “health-beauty.fragrance-cologne”.\nKeywords: [[[\"health\", \"beauty\"], [\"fragrance\", \"cologne\"]]] Embeddings: I create embeddings for “health”, “beauty”, “fragrance”, and “cologne”. Similarity: I compare each to the deal description embedding. “health” and “beauty” likely have low similarity; “fragrance” and “cologne” have high similarity. Removal: “health” and “beauty” are removed. Result: The cleaned category becomes “fragrance-cologne”. This “cleaned” category is then used in the LLM prompt, providing a much more focused and relevant hint. This significantly boosts the accuracy of the LLM’s suggestions.\nThe Full Code Here’s a more complete view of the code, including helper functions and the LLM interaction:\nimport { calculateCosineSimilarity } from './similarity'; import canonicalCategoryData from './canonical_categories.json'; import { getAIClient } from './ai_client'; import { AppLogger } from './logger'; type CategoryData = typeof canonicalCategoryData; const SIMILARITY_THRESHOLD = 0.8; const KEYWORD_SIMILARITY_THRESHOLD = 0.75; async function findBestMatch\u003cT extends string\u003e( { title, description, existingCategories, sourceEmbedding, comparisonEmbeddings }: { title: string; description: string; existingCategories?: string | null; sourceEmbedding: Array\u003cnumber\u003e | null; comparisonEmbeddings: Array\u003c[T, Array\u003cnumber\u003e]\u003e }, logger: AppLogger ): Promise\u003cT | undefined\u003e { let bestMatch: string | null = null; let highestScore = -Infinity; const { createTextEmbedding } = getAIClient(logger); if (sourceEmbedding !== null) { // Calculate cosine similarities and find the best match (embedding stage). comparisonEmbeddings.forEach(([targetCategory, targetEmbedding]) =\u003e { const similarity = calculateCosineSimilarity(sourceEmbedding, targetEmbedding); if (similarity \u003e highestScore) { highestScore = similarity; bestMatch = targetCategory; } }); } if (highestScore \u003e= SIMILARITY_THRESHOLD) return bestMatch as T; // --- LLM Fallback (if embedding similarity is low) --- const targetCategoryNames = comparisonEmbeddings.map(([category]) =\u003e category); // No existing categories? Simple LLM prompt. if (!existingCategories) { return await getCategorySuggestion\u003cT\u003e( `Product title: ${title}\\nProduct description: ${description}\\nAvailable categories:\\n`, targetCategoryNames, logger ); } // Existing categories? Refine them *first*! const categoryKeywords = existingCategories.split(/[^a-zA-Z0-9]/g); const keywordEmbeddings = await Promise.all(categoryKeywords.map((keyword) =\u003e createTextEmbedding(keyword))); const productEmbeddingWithoutCategories = await createTextEmbedding(`${title} ${description}`); if (keywordEmbeddings.every((e) =\u003e e !== null) \u0026\u0026 productEmbeddingWithoutCategories) { const similarities = (keywordEmbeddings as unknown as number[][]).map((embedding) =\u003e calculateCosineSimilarity(embedding, productEmbeddingWithoutCategories) ); const refinedCategories = refineExistingCategories(existingCategories, similarities); const prompt = `Product title: ${title}\\nProduct description: ${description}\\nPrevious categories: ${refinedCategories}\\nAvailable categories:\\n`; return await getCategorySuggestion\u003cT\u003e(prompt, targetCategoryNames, logger); } } async function getCategorySuggestion\u003cT extends string\u003e( partialPrompt: string, availableCategories: T[], logger: AppLogger ): Promise\u003cT | undefined\u003e { const { createChatCompletion } = getAIClient(logger); const suggestion = await createChatCompletion({ systemMessage: 'You are a categorization assistant that helps choose new product categories during a taxonomy migration.', userMessage: `${partialPrompt}${availableCategories.join(', ')}\\nNew category:`, }); if (!suggestion) { return undefined; } // Ensure the suggestion is one of the available categories (case-insensitive). return availableCategories.find((c) =\u003e c.toLowerCase() === suggestion.trim().toLowerCase()); } export function prepareCategories(categories: string) { return [...new Set(categories.split(/[^a-zA-Z0-9]/g))].join(' ') } export async function migrateCategory( dealDetails: { title: string; description: string; existingCategories?: string | null; }, logger: AppLogger ) { const { createTextEmbedding } = getAIClient(logger); const { title, description, existingCategories } = dealDetails; const dealEmbedding = await createTextEmbedding( `${title} ${description}${existingCategories ? ` ${prepareCategories(existingCategories)}` : ''}` ); const topLevelCategories = Object.entries(canonicalCategoryData).map\u003c [keyof CategoryData, number[]] \u003e(([key, data]) =\u003e [key, data.embedding]); const topLevelMatch = await findBestMatch\u003ckeyof CategoryData\u003e( { sourceEmbedding: dealEmbedding, comparisonEmbeddings: topLevelCategories, title, description, existingCategories, }, logger ); if (!topLevelMatch) { return null; } const subLevelMatch = await findBestMatch\u003cstring\u003e( { title, description, existingCategories, sourceEmbedding: dealEmbedding, comparisonEmbeddings: canonicalCategoryData[topLevelMatch].children as [string, number[]][], }, logger ); return [topLevelMatch, subLevelMatch].filter(Boolean).join('.'); } Key Results and Benefits This AI-powered migration system was a huge success. It allowed me to:\nDramatically improve accuracy: The combination of embeddings and LLMs significantly outperformed any manual or rule-based approach I could have devised. Save enormous amounts of time: What would have taken weeks or months of manual effort was completed in a fraction of the time. Ensure consistency: The automated system applied the new taxonomy consistently across all deals. Handle complexity: The system gracefully handled variations in product descriptions and ambiguities in the existing categories. Be adaptable: I can easily fine-tune the system (e.g., adjust the similarity thresholds) or update it as the canonical category structure evolves. This task is an example of how AI can be used to tackle complex, real-world data challenges. By combining different AI techniques and focusing on the nuances of the problem, I was able to build a solution that was both powerful and practical. The key was understanding the strengths of each approach – embeddings for efficient similarity matching, LLMs for contextual understanding, and careful preprocessing to clean up noisy data – and combining them in a resilient way.\n",
  "wordCount" : "1760",
  "inLanguage": "en",
  "datePublished": "2023-07-01T00:00:00Z",
  "dateModified": "2023-07-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lei Huang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://leihuang.me/posts/category-mapping-with-embedding/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lei Huang",
    "logo": {
      "@type": "ImageObject",
      "url": "https://leihuang.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://leihuang.me/" accesskey="h" title="Lei Huang (Alt + H)">Lei Huang</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://leihuang.me/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://leihuang.me/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://leihuang.me/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://leihuang.me/">Home</a>&nbsp;»&nbsp;<a href="https://leihuang.me/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Category Mapping with Embedding
    </h1>
    <div class="post-description">
      A deep dive into how I used embeddings and LLMs to automate a complex product categorization migration, cleaning up messy data along the way.
    </div>
    <div class="post-meta"><span title='2023-07-01 00:00:00 +0000 UTC'>July 1, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Lei Huang

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#the-challenge-bridging-the-old-and-new" aria-label="The Challenge: Bridging the Old and New">The Challenge: Bridging the Old and New</a></li>
                <li>
                    <a href="#my-ai-powered-solution-a-two-stage-migration" aria-label="My AI-Powered Solution: A Two-Stage Migration">My AI-Powered Solution: A Two-Stage Migration</a><ul>
                        
                <li>
                    <a href="#stage-1-embedding-based-similarity--finding-the-right-neighborhood" aria-label="Stage 1: Embedding-Based Similarity – Finding the Right Neighborhood">Stage 1: Embedding-Based Similarity – Finding the Right Neighborhood</a></li>
                <li>
                    <a href="#stage-2-llm-reasoning--refining-the-choice" aria-label="Stage 2: LLM Reasoning – Refining the Choice">Stage 2: LLM Reasoning – Refining the Choice</a></li></ul>
                </li>
                <li>
                    <a href="#the-key-cleaning-up-the-existing-categories" aria-label="The Key: Cleaning Up the Existing Categories">The Key: Cleaning Up the Existing Categories</a></li>
                <li>
                    <a href="#the-full-code" aria-label="The Full Code">The Full Code</a></li>
                <li>
                    <a href="#key-results-and-benefits" aria-label="Key Results and Benefits">Key Results and Benefits</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Recently, I faced a daunting task: migrating all of our existing product deals to a brand new, more comprehensive, and standardized set of canonical product categories. This was critical for improving product discoverability, ensuring consistent marketing, and enabling better reporting. Think of it as moving from a somewhat disorganized, ad-hoc filing system to a meticulously organized, hierarchical library catalog.</p>
<p>The problem? Our system had <em>tens of thousands</em> of deals, each with existing category assignments that were often inconsistent, incomplete, or simply didn&rsquo;t map cleanly to the new structure. Manually re-categorizing everything was out of the question. It would have taken an absurd amount of time and been incredibly prone to errors. I needed an automated solution, but a simple keyword-based approach wouldn&rsquo;t work. The nuances of product descriptions and the potential mismatches between the old and new categories demanded something far more intelligent.</p>
<h2 id="the-challenge-bridging-the-old-and-new">The Challenge: Bridging the Old and New<a hidden class="anchor" aria-hidden="true" href="#the-challenge-bridging-the-old-and-new">#</a></h2>
<p>The core challenge was bridging the semantic gap between the <em>existing</em> (often messy) category assignments and the <em>new</em> canonical categories. Here are a few examples to illustrate the problem:</p>
<ul>
<li><strong>Old:</strong> &ldquo;mens-clothing.shirts-t-shirts&rdquo; <strong>New:</strong> &ldquo;Apparel.Men&rsquo;s.Tops.T-Shirts&rdquo;</li>
<li><strong>Old:</strong> &ldquo;health-beauty.fragrance-cologne&rdquo; <strong>New:</strong> &ldquo;Beauty &amp; Personal Care.Fragrances.Men&rsquo;s Fragrances&rdquo;</li>
<li><strong>Old:</strong> &ldquo;home-decor&rdquo; <strong>New:</strong> &ldquo;Home &amp; Garden.Home Decor.Candles &amp; Home Fragrances&rdquo; (for a scented candle deal)</li>
</ul>
<p>The old categories could be incomplete, use different wording, or have a different level of granularity. I couldn&rsquo;t just create a simple lookup table. I needed a system that could:</p>
<ol>
<li><strong>Understand the <em>meaning</em></strong> of the product description, going beyond simple keyword matching.</li>
<li><strong>Leverage the <em>existing</em> category information</strong>, even if imperfect, as a valuable hint.</li>
<li><strong>Intelligently select the best match</strong> within the <em>new</em> canonical category hierarchy.</li>
</ol>
<h2 id="my-ai-powered-solution-a-two-stage-migration">My AI-Powered Solution: A Two-Stage Migration<a hidden class="anchor" aria-hidden="true" href="#my-ai-powered-solution-a-two-stage-migration">#</a></h2>
<p>I developed a two-stage AI-powered system that combines the strengths of embedding-based similarity matching and the contextual reasoning of large language models (LLMs).</p>
<h3 id="stage-1-embedding-based-similarity--finding-the-right-neighborhood">Stage 1: Embedding-Based Similarity – Finding the Right Neighborhood<a hidden class="anchor" aria-hidden="true" href="#stage-1-embedding-based-similarity--finding-the-right-neighborhood">#</a></h3>
<p>The first stage leverages pre-computed embeddings of the <em>new</em> canonical categories. Embeddings are numerical representations that capture the semantic meaning of text. Similar concepts have similar embeddings. I calculated the embedding of each product deal&rsquo;s description (including the title and any existing category information, after some complex preprocessing). Then, I compared this &ldquo;deal embedding&rdquo; to the embeddings of all the <em>top-level</em> categories in the new taxonomy.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// (Simplified representation)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">calculateCosineSimilarity</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./similarity&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">canonicalCategoryData</span> <span class="kr">from</span> <span class="s1">&#39;./canonical_categories.json&#39;</span><span class="p">;</span> <span class="c1">// My NEW category embeddings
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">import</span> <span class="p">{</span> <span class="nx">getAIClient</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./ai_client&#39;</span><span class="p">;</span> <span class="c1">// Interface to AI models
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">migrateCategory</span><span class="p">(</span><span class="nx">dealDetails</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">{</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">description</span><span class="p">,</span> <span class="nx">existingCategories</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">dealDetails</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">{</span> <span class="nx">createTextEmbedding</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">getAIClient</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 1. Create an embedding for the deal, including (preprocessed) existing categories.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">dealEmbedding</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">createTextEmbedding</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="sb">`</span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">description</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">existingCategories</span> <span class="o">?</span> <span class="nx">prepareCategories</span><span class="p">(</span><span class="nx">existingCategories</span><span class="p">)</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="si">}</span><span class="sb">`</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. Compare against top-level canonical category embeddings.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">topLevelCategories</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">canonicalCategoryData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">data</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">embedding</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">bestMatch</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">highestScore</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="p">[</span><span class="nx">categoryName</span><span class="p">,</span> <span class="nx">categoryEmbedding</span><span class="p">]</span> <span class="k">of</span> <span class="nx">topLevelCategories</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">similarity</span> <span class="o">=</span> <span class="nx">calculateCosineSimilarity</span><span class="p">(</span><span class="nx">dealEmbedding</span><span class="p">,</span> <span class="nx">categoryEmbedding</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">similarity</span> <span class="o">&gt;</span> <span class="nx">highestScore</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">highestScore</span> <span class="o">=</span> <span class="nx">similarity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">bestMatch</span> <span class="o">=</span> <span class="nx">categoryName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (continued below)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>I used cosine similarity to measure how &ldquo;close&rdquo; the embeddings are. A score of 1 is a perfect match; -1 is completely opposite. This quickly and efficiently identifies the <em>general area</em> within the new category structure where the deal likely belongs. If the similarity score exceeds a threshold (I used 0.8), I&rsquo;m confident enough to assign the deal to that top-level category.  Then, I repeat the process with the <em>sub-categories</em> of that top-level to get a more precise placement (e.g., &ldquo;Apparel&rdquo; -&gt; &ldquo;Men&rsquo;s&rdquo; -&gt; &ldquo;Tops&rdquo; -&gt; &ldquo;T-Shirts&rdquo;).</p>
<h3 id="stage-2-llm-reasoning--refining-the-choice">Stage 2: LLM Reasoning – Refining the Choice<a hidden class="anchor" aria-hidden="true" href="#stage-2-llm-reasoning--refining-the-choice">#</a></h3>
<p>What if the embedding similarity is <em>below</em> my threshold? This is where the LLM comes in, handling cases where:</p>
<ul>
<li>The deal description is brief or uses unusual language.</li>
<li>The existing categories are particularly unhelpful or misleading.</li>
<li>The best fit in the new taxonomy isn&rsquo;t immediately obvious.</li>
</ul>
<p>I construct a prompt for the LLM that includes:</p>
<ul>
<li>The deal&rsquo;s title and description.</li>
<li>The (potentially cleaned-up) <em>existing</em> categories.</li>
<li>A list of the <em>new</em> canonical categories to choose from.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="c1">// (Continuing from the previous code snippet)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">SIMILARITY_THRESHOLD</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">migrateCategory</span><span class="p">(</span><span class="nx">dealDetails</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... (previous code)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// If similarity is high enough, we&#39;re done!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">highestScore</span> <span class="o">&gt;=</span> <span class="nx">SIMILARITY_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="nx">subCategories</span> <span class="o">=</span> <span class="nx">canonicalCategoryData</span><span class="p">[</span><span class="nx">bestMatch</span><span class="p">].</span><span class="nx">children</span><span class="p">;</span> <span class="c1">// Get sub-categories
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">subCategoryMatch</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">findBestSubCategory</span><span class="p">(</span><span class="nx">dealEmbedding</span><span class="p">,</span> <span class="nx">subCategories</span><span class="p">);</span> <span class="c1">// Find the best sub-category
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="p">[</span><span class="nx">bestMatch</span><span class="p">,</span> <span class="nx">subCategoryMatch</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nb">Boolean</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">);</span> <span class="c1">// Return &#34;TopLevel.SubLevel&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If similarity is low, bring in the LLM.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">availableCategories</span> <span class="o">=</span> <span class="nx">topLevelCategories</span><span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">categoryName</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">categoryName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">suggestedCategory</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getCategorySuggestion</span><span class="p">(</span><span class="nx">dealDetails</span><span class="p">,</span> <span class="nx">availableCategories</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">suggestedCategory</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The <code>getCategorySuggestion</code> function (shown later) interacts with the LLM, providing the prompt and receiving the suggested category. The LLM acts like a &ldquo;smart categorizer,&rdquo; using its contextual understanding to make the best decision.</p>
<h2 id="the-key-cleaning-up-the-existing-categories">The Key: Cleaning Up the Existing Categories<a hidden class="anchor" aria-hidden="true" href="#the-key-cleaning-up-the-existing-categories">#</a></h2>
<p>The most crucial and, I think, trickiest part of my solution is how I handle the <em>existing</em> category information. I can&rsquo;t just ignore it; it often contains valuable clues.  But I can&rsquo;t trust it blindly, either. The <code>refineExistingCategories</code> function is the key to this delicate balance.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">refineExistingCategories</span><span class="p">(</span><span class="nx">categories</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">similarityScores</span>: <span class="kt">number</span><span class="p">[])</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">keywords</span> <span class="o">=</span> <span class="nx">categories</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">cat</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">cat</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">).</span><span class="nx">map</span><span class="p">((</span><span class="nx">subCat</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">subCat</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">filterKeywords</span><span class="p">(</span><span class="nx">arr</span>: <span class="kt">any</span><span class="p">[])</span><span class="o">:</span> <span class="kt">any</span><span class="p">[]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">arr</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nx">filterKeywords</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// THIS IS THE CORE LOGIC: Remove keywords with low similarity.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">similarityScores</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">KEYWORD_SIMILARITY_THRESHOLD</span> <span class="o">?</span> <span class="nx">item</span> : <span class="kt">null</span>
</span></span><span class="line"><span class="cl">      <span class="p">})</span>
</span></span><span class="line"><span class="cl">      <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">item</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="nx">filterKeywords</span><span class="p">(</span><span class="nx">keywords</span><span class="p">)</span> <span class="kr">as</span> <span class="kt">string</span><span class="p">[][][])</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">category</span><span class="p">)</span> <span class="o">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">category</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">subCategory</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nx">subCategory</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Here&rsquo;s a breakdown:</p>
<ol>
<li>
<p><strong>Deconstruct:</strong> I break down the existing categories into a hierarchical structure of individual keywords.  For example, &ldquo;health-beauty.fragrance-cologne,mens-clothing&rdquo; becomes <code>[[[&quot;health&quot;, &quot;beauty&quot;], [&quot;fragrance&quot;, &quot;cologne&quot;]], [[&quot;mens&quot;, &quot;clothing&quot;]]]</code>.</p>
</li>
<li>
<p><strong>Individual Keyword Embeddings:</strong> I create an embedding for <em>each individual keyword</em> from the old categories.</p>
</li>
<li>
<p><strong>Similarity Check:</strong> I compare <em>each keyword embedding</em> to the embedding of the deal description ( <em>without</em> the old categories). This measures how relevant each <em>individual keyword</em> is to the <em>core</em> product information.</p>
</li>
<li>
<p><strong>Strategic Removal:</strong> If a keyword&rsquo;s similarity is <em>below</em> a threshold (<code>KEYWORD_SIMILARITY_THRESHOLD</code>, which I set to 0.75), I <em>remove</em> it. This eliminates noise and prevents misleading information from influencing the LLM.</p>
</li>
<li>
<p><strong>Reconstruct:</strong> I rebuild the &ldquo;cleaned&rdquo; existing categories string using only the remaining keywords.</p>
</li>
</ol>
<p><strong>Example:</strong></p>
<p>Let&rsquo;s say a deal for a men&rsquo;s cologne has the old category &ldquo;health-beauty.fragrance-cologne&rdquo;.</p>
<ol>
<li><strong>Keywords:</strong> <code>[[[&quot;health&quot;, &quot;beauty&quot;], [&quot;fragrance&quot;, &quot;cologne&quot;]]]</code></li>
<li><strong>Embeddings:</strong> I create embeddings for &ldquo;health&rdquo;, &ldquo;beauty&rdquo;, &ldquo;fragrance&rdquo;, and &ldquo;cologne&rdquo;.</li>
<li><strong>Similarity:</strong> I compare each to the deal description embedding. &ldquo;health&rdquo; and &ldquo;beauty&rdquo; likely have <em>low</em> similarity; &ldquo;fragrance&rdquo; and &ldquo;cologne&rdquo; have <em>high</em> similarity.</li>
<li><strong>Removal:</strong> &ldquo;health&rdquo; and &ldquo;beauty&rdquo; are removed.</li>
<li><strong>Result:</strong> The cleaned category becomes &ldquo;fragrance-cologne&rdquo;.</li>
</ol>
<p>This &ldquo;cleaned&rdquo; category is then used in the LLM prompt, providing a much more focused and relevant hint. This significantly boosts the accuracy of the LLM&rsquo;s suggestions.</p>
<h2 id="the-full-code">The Full Code<a hidden class="anchor" aria-hidden="true" href="#the-full-code">#</a></h2>
<p>Here&rsquo;s a more complete view of the code, including helper functions and the LLM interaction:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">calculateCosineSimilarity</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./similarity&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="nx">canonicalCategoryData</span> <span class="kr">from</span> <span class="s1">&#39;./canonical_categories.json&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">getAIClient</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./ai_client&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">AppLogger</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./logger&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">CategoryData</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">canonicalCategoryData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">SIMILARITY_THRESHOLD</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">KEYWORD_SIMILARITY_THRESHOLD</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">findBestMatch</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">string</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">description</span><span class="p">,</span> <span class="nx">existingCategories</span><span class="p">,</span> <span class="nx">sourceEmbedding</span><span class="p">,</span> <span class="nx">comparisonEmbeddings</span> <span class="p">}</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">title</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">description</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">existingCategories?</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">sourceEmbedding</span>: <span class="kt">Array</span><span class="p">&lt;</span><span class="nt">number</span><span class="p">&gt;</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">comparisonEmbeddings</span>: <span class="kt">Array</span><span class="o">&lt;</span><span class="p">[</span><span class="nx">T</span><span class="p">,</span> <span class="nb">Array</span><span class="p">&lt;</span><span class="nt">number</span><span class="p">&gt;]</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">logger</span>: <span class="kt">AppLogger</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">Promise</span><span class="p">&lt;</span><span class="nt">T</span> <span class="err">|</span> <span class="na">undefined</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">bestMatch</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">highestScore</span> <span class="o">=</span> <span class="o">-</span><span class="kc">Infinity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="p">{</span> <span class="nx">createTextEmbedding</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">getAIClient</span><span class="p">(</span><span class="nx">logger</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">sourceEmbedding</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate cosine similarities and find the best match (embedding stage).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">comparisonEmbeddings</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">targetCategory</span><span class="p">,</span> <span class="nx">targetEmbedding</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kr">const</span> <span class="nx">similarity</span> <span class="o">=</span> <span class="nx">calculateCosineSimilarity</span><span class="p">(</span><span class="nx">sourceEmbedding</span><span class="p">,</span> <span class="nx">targetEmbedding</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">similarity</span> <span class="o">&gt;</span> <span class="nx">highestScore</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">highestScore</span> <span class="o">=</span> <span class="nx">similarity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">bestMatch</span> <span class="o">=</span> <span class="nx">targetCategory</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">highestScore</span> <span class="o">&gt;=</span> <span class="nx">SIMILARITY_THRESHOLD</span><span class="p">)</span> <span class="k">return</span> <span class="nx">bestMatch</span> <span class="kr">as</span> <span class="nx">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// --- LLM Fallback (if embedding similarity is low) ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">targetCategoryNames</span> <span class="o">=</span> <span class="nx">comparisonEmbeddings</span><span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">category</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">category</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// No existing categories? Simple LLM prompt.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">existingCategories</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">await</span> <span class="nx">getCategorySuggestion</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">      <span class="sb">`Product title: </span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="err">\</span><span class="sb">nProduct description: </span><span class="si">${</span><span class="nx">description</span><span class="si">}</span><span class="err">\</span><span class="sb">nAvailable categories:</span><span class="err">\</span><span class="sb">n`</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">targetCategoryNames</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">logger</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Existing categories?  Refine them *first*!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kr">const</span> <span class="nx">categoryKeywords</span> <span class="o">=</span> <span class="nx">existingCategories</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[^a-zA-Z0-9]/g</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">keywordEmbeddings</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">categoryKeywords</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">keyword</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">createTextEmbedding</span><span class="p">(</span><span class="nx">keyword</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">productEmbeddingWithoutCategories</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">createTextEmbedding</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">description</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">keywordEmbeddings</span><span class="p">.</span><span class="nx">every</span><span class="p">((</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">e</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">productEmbeddingWithoutCategories</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">similarities</span> <span class="o">=</span> <span class="p">(</span><span class="nx">keywordEmbeddings</span> <span class="kr">as</span> <span class="kt">unknown</span> <span class="kr">as</span> <span class="kt">number</span><span class="p">[][]).</span><span class="nx">map</span><span class="p">((</span><span class="nx">embedding</span><span class="p">)</span> <span class="o">=&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">calculateCosineSimilarity</span><span class="p">(</span><span class="nx">embedding</span><span class="p">,</span> <span class="nx">productEmbeddingWithoutCategories</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">refinedCategories</span> <span class="o">=</span> <span class="nx">refineExistingCategories</span><span class="p">(</span><span class="nx">existingCategories</span><span class="p">,</span> <span class="nx">similarities</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">prompt</span> <span class="o">=</span> <span class="sb">`Product title: </span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="err">\</span><span class="sb">nProduct description: </span><span class="si">${</span><span class="nx">description</span><span class="si">}</span><span class="err">\</span><span class="sb">nPrevious categories: </span><span class="si">${</span><span class="nx">refinedCategories</span><span class="si">}</span><span class="err">\</span><span class="sb">nAvailable categories:</span><span class="err">\</span><span class="sb">n`</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">await</span> <span class="nx">getCategorySuggestion</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">prompt</span><span class="p">,</span> <span class="nx">targetCategoryNames</span><span class="p">,</span> <span class="nx">logger</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">getCategorySuggestion</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">string</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">partialPrompt</span>: <span class="kt">string</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">availableCategories</span>: <span class="kt">T</span><span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="nx">logger</span>: <span class="kt">AppLogger</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">Promise</span><span class="p">&lt;</span><span class="nt">T</span> <span class="err">|</span> <span class="na">undefined</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="p">{</span> <span class="nx">createChatCompletion</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">getAIClient</span><span class="p">(</span><span class="nx">logger</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">suggestion</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">createChatCompletion</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">        <span class="nx">systemMessage</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">            <span class="s1">&#39;You are a categorization assistant that helps choose new product categories during a taxonomy migration.&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">userMessage</span><span class="o">:</span> <span class="sb">`</span><span class="si">${</span><span class="nx">partialPrompt</span><span class="si">}${</span><span class="nx">availableCategories</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span><span class="si">}</span><span class="err">\</span><span class="sb">nNew category:`</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">suggestion</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Ensure the suggestion is one of the available categories (case-insensitive).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">availableCategories</span><span class="p">.</span><span class="nx">find</span><span class="p">((</span><span class="nx">c</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="o">===</span> <span class="nx">suggestion</span><span class="p">.</span><span class="nx">trim</span><span class="p">().</span><span class="nx">toLowerCase</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">prepareCategories</span><span class="p">(</span><span class="nx">categories</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[...</span><span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="nx">categories</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[^a-zA-Z0-9]/g</span><span class="p">))].</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">async</span> <span class="kd">function</span> <span class="nx">migrateCategory</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">dealDetails</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">title</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">description</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">existingCategories?</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">logger</span>: <span class="kt">AppLogger</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="p">{</span> <span class="nx">createTextEmbedding</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">getAIClient</span><span class="p">(</span><span class="nx">logger</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="p">{</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">description</span><span class="p">,</span> <span class="nx">existingCategories</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">dealDetails</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">dealEmbedding</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">createTextEmbedding</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="sb">`</span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">description</span><span class="si">}${</span><span class="nx">existingCategories</span> <span class="o">?</span> <span class="sb">` </span><span class="si">${</span><span class="nx">prepareCategories</span><span class="p">(</span><span class="nx">existingCategories</span><span class="p">)</span><span class="si">}</span><span class="sb">`</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="si">}</span><span class="sb">`</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">topLevelCategories</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">canonicalCategoryData</span><span class="p">).</span><span class="nx">map</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">        <span class="p">[</span><span class="k">keyof</span> <span class="nx">CategoryData</span><span class="p">,</span> <span class="kt">number</span><span class="p">[]]</span>
</span></span><span class="line"><span class="cl">    <span class="o">&gt;</span><span class="p">(([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">data</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">embedding</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">topLevelMatch</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">findBestMatch</span><span class="p">&lt;</span><span class="nt">keyof</span> <span class="na">CategoryData</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sourceEmbedding</span>: <span class="kt">dealEmbedding</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">comparisonEmbeddings</span>: <span class="kt">topLevelCategories</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">title</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">description</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">existingCategories</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="nx">logger</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">topLevelMatch</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">subLevelMatch</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">findBestMatch</span><span class="p">&lt;</span><span class="nt">string</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">title</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">description</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">existingCategories</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">sourceEmbedding</span>: <span class="kt">dealEmbedding</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">comparisonEmbeddings</span>: <span class="kt">canonicalCategoryData</span><span class="p">[</span><span class="nx">topLevelMatch</span><span class="p">].</span><span class="nx">children</span> <span class="kr">as</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="p">[]][],</span>
</span></span><span class="line"><span class="cl">        <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="nx">logger</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="nx">topLevelMatch</span><span class="p">,</span> <span class="nx">subLevelMatch</span><span class="p">].</span><span class="nx">filter</span><span class="p">(</span><span class="nb">Boolean</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="key-results-and-benefits">Key Results and Benefits<a hidden class="anchor" aria-hidden="true" href="#key-results-and-benefits">#</a></h2>
<p>This AI-powered migration system was a huge success. It allowed me to:</p>
<ul>
<li><strong>Dramatically improve accuracy:</strong> The combination of embeddings and LLMs significantly outperformed any manual or rule-based approach I could have devised.</li>
<li><strong>Save enormous amounts of time:</strong> What would have taken weeks or months of manual effort was completed in a fraction of the time.</li>
<li><strong>Ensure consistency:</strong> The automated system applied the new taxonomy consistently across all deals.</li>
<li><strong>Handle complexity:</strong> The system gracefully handled variations in product descriptions and ambiguities in the existing categories.</li>
<li><strong>Be adaptable:</strong> I can easily fine-tune the system (e.g., adjust the similarity thresholds) or update it as the canonical category structure evolves.</li>
</ul>
<p>This task is an example of how AI can be used to tackle complex, real-world data challenges. By combining different AI techniques and focusing on the nuances of the problem, I was able to build a solution that was both powerful and practical. The key was understanding the strengths of each approach – embeddings for efficient similarity matching, LLMs for contextual understanding, and careful preprocessing to clean up noisy data – and combining them in a resilient way.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://leihuang.me/posts/time-slicing-with-coroutine/">
    <span class="title">Next »</span>
    <br>
    <span>Time-slicing With Coroutine</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Category Mapping with Embedding on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fleihuang.me%2fposts%2fcategory-mapping-with-embedding%2f&amp;title=Category%20Mapping%20with%20Embedding&amp;summary=Category%20Mapping%20with%20Embedding&amp;source=https%3a%2f%2fleihuang.me%2fposts%2fcategory-mapping-with-embedding%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Category Mapping with Embedding on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fleihuang.me%2fposts%2fcategory-mapping-with-embedding%2f&title=Category%20Mapping%20with%20Embedding">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Category Mapping with Embedding on whatsapp"
            href="https://api.whatsapp.com/send?text=Category%20Mapping%20with%20Embedding%20-%20https%3a%2f%2fleihuang.me%2fposts%2fcategory-mapping-with-embedding%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© 2025 Lei Huang</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
